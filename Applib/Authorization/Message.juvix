module Applib.Authorization.Message;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Stdlib.Data.Set as Set open using {Set};
import Applib.Helpers open;
import Applib.Identities open;

import Anoma open;
import Anoma.Builtin.System open;

--- A message format specifiying resources that must be created and consumed within an ;Action;.
--- @param origin The resource performing the check.
--- @param mustBeConsumed The resources that must be consumed.
--- @param mustBeCreated The resources that must be created.
type ResourceRelationship :=
  mkResourceRelationship@{
    --- The ;Tag; of the resource performing the check.
    origin : Tag;
    --- The  performing the check.
    mustBeConsumed : Set Nullifier;
    mustBeCreated : Set Commitment;
  };

mkResourceRelationshipAppDataEntry
  (identity : Identity)
  (origin : Tag)
  (mustBeConsumed : Set Nullifier)
  (mustBeCreated : Set Commitment)
  : AppDataEntry :=
  let
    msg : ResourceRelationship :=
      mkResourceRelationship@{
        origin;
        mustBeConsumed;
        mustBeCreated;
      };
    sig : Signature := sign msg (Identity.internal identity);
  in case origin of
       | Created commitment :=
         mkAppDataEntry@{
           key := commitment |> anomaEncode |> mkAppDataKey;
           value := (msg, sig) |> anomaEncode |> mkAppDataValue;
         }
       | Consumed nullifier :=
         mkAppDataEntry@{
           key := nullifier |> anomaEncode |> mkAppDataKey;
           value := (msg, sig) |> anomaEncode |> mkAppDataValue;
         };

module ActionFromConvertable;
  import Applib.Resource.Traits.Convertable open;
  import Applib.Transaction.Traits open;

  --- Creates an app data map entry for every consumed ;Convertable; ;Resource; of type `R1` with a ;ResourceRelationship; message and signature being stored at the consumed resources commitment  message. This message must be signed by the respective owner of the consumed resources and requires  all created ;Convertable; ;Resource; of type `R2` to be present in the ;Commitment; ;Set; of the transaction.
  actionWithAuthorizationAppData
    {R1 R2}
    {{Ord R1}}
    {{Ord R2}}
    {{Convertable R1}}
    {{Convertable R2}}
    : ActionConvertable R1 R2 :=
    mkActionConvertable@{
      toAction
        (standardInputs : StandardInputs)
        (consumedResources : Set R1)
        (createdResources : Set R2)
        : Action :=
        let
          identity := StandardInputs.identity standardInputs;
          consumed :=
            Set.map (r in consumedResources) {
              Convertable.toResource r
            };
          created :=
            Set.map (r in createdResources) {
              Convertable.toResource r
            };

          nfResMapping := nullifierToResourceMapping identity consumed;
          cmResMapping := commitmentToResourceMapping created;

          nullifiers := NullifiersAndCustomInputs.nullifiers nfResMapping;
          commitments := CommitmentsAndCustomInputs.commitments cmResMapping;

          customInputs :=
            Set.union
              (NullifiersAndCustomInputs.customInputs nfResMapping)
              (CommitmentsAndCustomInputs.customInputs cmResMapping);

          appData :=
            Set.map (nullifier in nullifiers) {
              mkResourceRelationshipAppDataEntry@{
                identity;
                origin := Consumed nullifier;
                mustBeConsumed := Set.empty;
                mustBeCreated := commitments;
              }
            };
          appDataMap := AppDataMap.fromSet appData;
        in mkActionHelper@{
             identity;
             consumed;
             created;
             appData;
             customInputs;
             maybeNullifiers := just nullifiers;
             maybeCommitments := just commitments;
           };
    };
end;
