module Applib.Helpers;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};

import Applib.Identities open;
import Stdlib.Data.Set as Set open using {
  Set;
  empty;
  size;
  insert;
  union;
  isMember;
};
import Stdlib.Data.Map as Map open using {Map};

import Anoma open;
import Anoma.State open;
import Anoma.Builtin.ByteArray open;
import Anoma.Builtin.System open;

import Applib.Random open;
import Applib.Resource.Traits.Convertable open;

instance
ExternalIdentity-Show : Show ExternalIdentity :=
  mkShow
    \{id :=
      id
        |> ExternalIdentity.unExternalIdentity
        |> toAnomaContents
        |> natToString};

instance
InternalIdentity-Show : Show InternalIdentity :=
  mkShow
    \{id :=
      id
        |> InternalIdentity.unInternalIdentity
        |> toAnomaContents
        |> natToString};

instance
Identity-Show : Show Identity :=
  mkShow
    \{id :=
      "{"
        ++str "external : "
        ++str (id |> Identity.external |> Show.show)
        ++str ", "
        ++str "internal : "
        ++str (id |> Identity.internal |> Show.show)
        ++str "}"};

isNullifierPresent
  (nullifier : Nullifier) (nullifierSet : Set Nullifier) : Bool :=
  Set.isMember nullifier nullifierSet;

module AppDataMap;
  fromSet (appDataSet : Set AppDataEntry) : Map AppDataKey AppDataValue :=
    Map.fromList
      (map (entry in Set.toList appDataSet) {
        AppDataEntry.key entry, AppDataEntry.value entry
      });

  toSet (appDataMap : Map AppDataKey AppDataValue) : Set AppDataEntry :=
    Set.fromList
      (map (key, value in Map.toList appDataMap) {
        mkAppDataEntry@{
          key;
          value;
        }
      });
end;

lookupAppData
  {Key Value : Type} (key : Key) (appData : AppData) : Maybe Value :=
  let
    appDataAsMap : Map AppDataKey AppDataValue := AppDataMap.fromSet appData;
  in map
    (AppDataValue.unAppDataValue >> anomaDecode)
    (Map.lookup (anomaEncode key |> mkAppDataKey) appDataAsMap);

lookupCustomInputs
  {Key Value : Type}
  (key : Key)
  (customInputs : Logic.CustomInputs)
  : Maybe Value :=
  lookupAppData@{
    key;
    appData := customInputs;
  };

lookupResource
  {A} (key : A) (customInputs : Logic.CustomInputs) : Maybe Resource :=
  lookupCustomInputs@{
    key;
    customInputs;
  };

type StandardInputs :=
  mkStandardInputs@{
    identity : Identity;
    currentRoot : CommitmentTree.Root;
  };

computableComponentToCustomInputs
  {A} (f : Resource -> A) (resources : Set Resource) : Logic.CustomInputs :=
  Set.map (r in resources) {
    mkAppDataEntry@{
      key := r |> f |> anomaEncode |> mkAppDataKey;
      value := r |> anomaEncode |> mkAppDataValue;
    }
  };

toMapEntry {A} (k : A) (v : Resource) : AppDataEntry :=
  mkAppDataEntry@{
    key := k |> anomaEncode |> mkAppDataKey;
    value := v |> anomaEncode |> mkAppDataValue;
  };

type CommitmentsAndCustomInputs :=
  mkCommitmentsAndCustomInputs@{
    commitments : Set Commitment;
    customInputs : Logic.CustomInputs;
  };

type NullifiersAndCustomInputs :=
  mkNullifiersAndCustomInputs@{
    nullifiers : Set Nullifier;
    customInputs : Logic.CustomInputs;
  };

commitmentToResourceMapping
  (created : Set Resource) : CommitmentsAndCustomInputs :=
  let
    created' := Set.toList created;
    commitments' := map commitment created';
  in mkCommitmentsAndCustomInputs@{
       commitments := Set.fromList commitments';
       customInputs := Set.fromList (zipWith toMapEntry commitments' created');
     };

nullifierToResourceMapping
  (identity : Identity) (consumed : Set Resource) : NullifiersAndCustomInputs :=
  let
    consumed' := Set.toList consumed;
    nullifiers' := map (nullifier (toNullifierKey identity)) consumed';
  in mkNullifiersAndCustomInputs@{
       nullifiers := Set.fromList nullifiers';
       customInputs := Set.fromList (zipWith toMapEntry nullifiers' consumed');
     };

module ProvingHelpers;
  findProvingKey
    {T} (key : T) (customInputs : Logic.CustomInputs) : Logic.ProvingKey :=
    case
      lookupCustomInputs@{
        key;
        Value := Resource;
        customInputs;
      }
    of
      | just resource := Logic.mkProvingKey resource
      | nothing :=
        failwith
          "Error. The proving key could not be found. This should never happen.";

  createLogicProofRecord
    (tag : Tag)
    (publicInputs : Logic.Instance)
    (privateInputs : Logic.Witness)
    : ProofRecord :=
    let
      customInputs := Logic.Witness.customInputs privateInputs;
      provingKey :=
        case tag of
          | Consumed nf := findProvingKey nf customInputs
          | Created cm := findProvingKey cm customInputs;
      proof : Logic.Proof :=
        Logic.prove@{
          provingKey;
          publicInputs;
          privateInputs;
        };
      verifyingKey := Logic.mkVerifyingKey unit;
      proofRecord := Logic.mkProofRecord proof verifyingKey publicInputs;
    in LogicProofRecord proofRecord;

  emptyComplianceProofRecord : Compliance.ProofRecord :=
    let
      verifyingKey := Compliance.mkVerifyingKey unit;
      provingKey := Compliance.mkProvingKey unit;
      publicInputs := Compliance.mkInstance unit;
      privateInputs := Compliance.mkWitness unit;
      proof :=
        Compliance.prove@{
          provingKey;
          publicInputs;
          privateInputs;
        };
    in Compliance.mkProofRecord proof verifyingKey publicInputs;

  createComplianceProofRecord : ProofRecord :=
    ComplianceProofRecord emptyComplianceProofRecord;

  emptyDeltaProofRecord : Delta.ProofRecord :=
    let
      verifyingKey := Delta.mkVerifyingKey unit;
      provingKey := Delta.mkProvingKey unit;
      publicInputs := Delta.mkInstance unit;
      privateInputs := Delta.mkWitness unit;
      proof :=
        Delta.prove@{
          provingKey;
          publicInputs;
          privateInputs;
        };
    in Delta.mkProofRecord proof verifyingKey publicInputs;

  createDeltaProofRecord : ProofRecord :=
    DeltaProofRecord emptyDeltaProofRecord;
end;

open ProvingHelpers;

--- Helps with the creation of an action ;Action;.
--- @param identity The identity to derive the nullifier key from.
--- @param consumed The resources being consumed in this action.
--- @param created The resources being created in this action.
--- @param appData The app data of the action.
--- @param customInputs The custom inputs of the action.
--- @param maybeNullifiers Optional nullifiers to avoid recomputation.
--- @param maybeCommitments Optional commitments to avoid recomputation.
--- @return The action object.
mkActionHelper
  (identity : Identity)
  (consumed created : Set Resource)
  (appData : AppData)
  (customInputs : Logic.CustomInputs)
  {maybeNullifiers : Maybe (Set Nullifier) := nothing}
  {maybeCommitments : Maybe (Set Commitment) := nothing}
  : Action :=
  let
    nullifierKey := toNullifierKey identity;
    nullifiers :=
      case maybeNullifiers of
        | nothing :=
          Set.map (r in consumed) {
            nullifier nullifierKey r
          }
        | just nullifiers := nullifiers;
    commitments :=
      case maybeCommitments of
        | nothing :=
          Set.map (r in created) {
            commitment r
          }
        | just commitments := commitments;

    tags : Set Tag :=
      Set.union
        Set.map (nullifier in nullifiers) {
          Consumed nullifier
        }
        Set.map (commitment in commitments) {
          Created commitment
        };

    logicProofs : Set ProofRecord :=
      Set.map (tag in tags) {
        createLogicProofRecord@{
          tag;
          publicInputs :=
            Logic.mkInstance@{
              tag;
              commitments;
              nullifiers;
              appData;
            };
          privateInputs :=
            Logic.mkWitness@{
              created;
              consumed;
              customInputs;
            };
        }
      };

    -- Populate the compliance proofs (that currently are empty).
    -- NOTE: Proof replicas will be deduplicated by ;Set;
    complianceProofs : Set ProofRecord :=
      Set.map (_ in tags) {
        createComplianceProofRecord
      };
  in mkAction@{
       commitments;
       nullifiers;
       proofRecords := Set.union logicProofs complianceProofs;
       appData;
     };

mkTransactionHelper
  (roots : Set CommitmentTree.Root) (actions : Set Action) : Transaction :=
  mkTransaction@{
    roots;
    actions;
    delta := Delta.zero;
    deltaProofRecord := createDeltaProofRecord;
  };

emptyTx : Transaction :=
  mkTransactionHelper@{
    roots := Set.empty;
    actions := Set.empty;
  };

composeAll (txs : Set Transaction) : Transaction :=
  for (acc := emptyTx) (tx in txs) {
    composeTransactions acc tx
  };

fromResult
  {ErrorType}
  {DataType}
  {{Show ErrorType}}
  (result : Result ErrorType DataType)
  : DataType :=
  case result of
    | ok data := data
    | error err := failwith (Show.show err);
