module Applib.Helpers;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};

import Applib.Identities open;
import Stdlib.Data.Set as Set open using {Set; empty; insert; union; isMember};
import Stdlib.Data.Map as Map open using {Map};
import Anoma open;
import Anoma.State open;
import Anoma.Builtin.ByteArray open;
import Anoma.Builtin.System open;
import BaseLayer.ResourceMachine as BaseLayer;

import Applib.Resource.Traits.Convertable open;

isNullifierPresent
  (nullifier : Nullifier) (nullifierSet : Set Nullifier) : Bool :=
  Set.isMember nullifier nullifierSet;

lookupResource {A} (key : A) (customInputs : CustomInputs) : Maybe Resource :=
  lookupCustomInputs@{
    key;
    customInputs;
  };

toAppDataEntry
  {Key Data : Type}
  (key : Key)
  (data : Data)
  {deletionCriterion : DeletionCriterion := StoreForever}
  : Pair AppDataKey AppDataValue :=

  mkAppDataKey@{
    unAppDataKey := anomaEncode key;
  }
    , mkAppDataValue@{
        data := anomaEncode data;
        deletionCriterion;
      };

toCustomInputsEntry
  {Key Value : Type}
  (key : Key)
  (value : Value)
  : Pair CustomInputsKey CustomInputsValue :=
  mkCustomInputsKey@{
    unCustomInputsKey := anomaEncode key;
  }
    , mkCustomInputsValue@{
        unCustomInputsValue := anomaEncode value;
      };

--- Standard inputs to for transaction functions.
--- NOTE: In the future, this will include more settings such as the information flow control flag.
type StandardInputs :=
  mkStandardInputs@{
    caller : Identity;
    currentRoot : CommitmentTree.Root;
    randSeed : RandSeed;
  };

type TagsAndCustomInputs :=
  mkTagsAndCustomInputs@{
    tags : List Tag;
    customInputs : CustomInputs;
  };

tagsToPair (tags : List Tag) : Pair (List Nullifier) (List Commitment) :=
      for (nfs, cms := [], []) (tag in tags) {
        case tag of
          | Consumed nf := nfs ++ [nf], cms
          | Created cm := nfs, cms ++ [cm]
      };

pairtoTags
  (nullifiers : Set Nullifier) (commitments : Set Commitment) : Set Tag :=
  Set.union
    Set.map (nullifier in nullifiers) {
      Consumed nullifier
    }
    Set.map (commitment in commitments) {
      Created commitment
    };

computeTags (consumed created : List Resource) : List Tag :=
  let
    nullifierTags :=
      map (r in consumed) {
        Consumed (nullifier r)
      };
    commitmentTags :=
      map (r in created) {
        Created (commitment r)
      };
  in nullifierTags ++ commitmentTags;

computeTagsAndCustomInputs
  (consumed created : List Resource) : TagsAndCustomInputs :=
  let
    consumed' : List Resource := consumed;
    created' : List Resource := created;

    nullifiers' : List Nullifier :=
      map nullifier consumed';
    commitments' : List Commitment := map commitment created';

    tags' : List Tag := map Consumed nullifiers' ++ map Created commitments';
  in mkTagsAndCustomInputs@{
       tags := tags';
       customInputs :=
         Map.fromList
           (zipWith toCustomInputsEntry tags' (consumed' ++ created'));
     };

module ProvingHelpers;
  findProvingKey
    {T} (key : T) (customInputs : CustomInputs) : Logic.ProvingKey :=
    case
      lookupCustomInputs@{
        key;
        Value := Resource;
        customInputs;
      }
    of
      | just resource := Logic.mkProvingKey resource
      | nothing :=
        failwith
          "Error. The proving key could not be found. This should never happen.";

  createLogicProofRecord
    (tag : Tag)
    (publicInputs : Logic.Instance)
    (privateInputs : Logic.Witness)
    : ProofRecord :=
    let
      customInputs := Logic.Witness.customInputs privateInputs;
      provingKey :=
        case tag of
          | Consumed nf := findProvingKey nf (anomaDecode customInputs)
          | Created cm := findProvingKey cm (anomaDecode customInputs);
      proof : Logic.Proof :=
        Logic.prove@{
          resource := provingKey;
          publicInputs;
          privateInputs;
        };
      verifyingKey := unit;
      proofRecord := Logic.mkProofRecord proof verifyingKey publicInputs;
    in LogicProofRecord proofRecord;

--   emptyComplianceProofRecord : Compliance.ProofRecord :=
--     let
--       verifyingKey := Compliance.mkVerifyingKey unit;
--       provingKey := Compliance.mkProvingKey unit;
--       publicInputs := Compliance.mkInstance unit;
--       privateInputs := Compliance.mkWitness unit;
--       proof :=
--         Compliance.prove@{
--           provingKey;
--           publicInputs;
--           privateInputs;
--         };
--     in Compliance.mkProofRecord proof verifyingKey publicInputs;

--   createComplianceProofRecord : ProofRecord :=
--     ComplianceProofRecord emptyComplianceProofRecord;

--   emptyDeltaProofRecord : Delta.ProofRecord :=
--     let
--       verifyingKey := Delta.mkVerifyingKey unit;
--       provingKey := Delta.mkProvingKey unit;
--       publicInputs := Delta.mkInstance unit;
--       privateInputs := Delta.mkWitness unit;
--       proof :=
--         Delta.prove@{
--           provingKey;
--           publicInputs;
--           privateInputs;
--         };
--     in Delta.mkProofRecord proof verifyingKey publicInputs;

--   createDeltaProofRecord : ProofRecord :=
--     DeltaProofRecord emptyDeltaProofRecord;
end;

open ProvingHelpers;

-- Helps with the creation of an action ;Action;.
-- @param identity The identity to derive the nullifier key from.
-- @param consumed The resources being consumed in this action.
-- @param created The resources being created in this action.
-- @param appData The app data of the action.
-- @param customInputs The custom inputs of the action.
-- @param maybeNullifiers Optional nullifiers to avoid recomputation.
-- @param maybeCommitments Optional commitments to avoid recomputation.
-- @return The action object.
mkActionHelper
  (consumed created : List Resource)
  (appData : Nat)
  (custom : CustomInputs)
  {tags : List Tag := computeTags@{
                       consumed;
                       created;
                     }}
  : Action :=
  let
    (nullifiers, commitments) := tagsToPair tags;
    rawNfs := map unNullifier nullifiers;
    rawCms := map unCommitment commitments;

    -- Compute proofs
    logicProofs : List ProofRecord :=
      map (tag in tags) {
        createLogicProofRecord@{
          tag;
          publicInputs :=
            Logic.mkInstance@{
              tag := tagToNat tag;
              commitments := rawCms;
              nullifiers := rawNfs;
              appData;
            };
          privateInputs :=
            Logic.mkWitness@{
              created;
              consumed;
              customInputs := anomaEncode custom;
            };
        }
      };
   complianceProofs := []
  in mkAction@{
       commitments := rawCms;
       nullifiers := rawNfs;
       proofs := map proofRecordToProof (logicProofs ++ complianceProofs);
       app-data := appData;
     };

logicProofRecordToProof (p : Logic.ProofRecord)  : Logic.Proof := Logic.ProofRecord.proof p;

proofRecordToProof : ProofRecord -> Logic.Proof
 | ComplianceProofRecord := failwith "proofRecordToProof"
  | (LogicProofRecord logProof) :=  logicProofRecordToProof logProof
  | DeltaProofRecord := failwith "proofRecordToProof";

mkTransactionHelper
  (roots : List CommitmentTree.Root) (actions : List Action) : Transaction :=
  mkTransaction@{
    roots := map CommitmentTree.unRoot roots;
    actions;
    delta := BaseLayer.zeroDelta;
    delta-proof := 0;
  };

emptyTx : Transaction :=
  mkTransactionHelper@{
    roots := [];
    actions := [];
  };

--- A helper function preparing the transaction object by creating an action object
--- containing data required by counter resources.
--- @param standardInputs The transaction function standard inputs.
--- @param consumed The consumed resources.
--- @param created The created resources.
--- @return The transaction object.
prepareStandardTransaction
  (standardInputs : StandardInputs)
  (consumed created : List Resource)
  {appData : Nat := anomaEncode emptyCustomInputs}
  : Transaction :=
  let
    -- Put maps into the custom inputs that map:
    -- - nullifiers to consumed resources
    -- - commitments to created resources
    tagsAndCustomInputs :=
      computeTagsAndCustomInputs@{
        consumed;
        created;
      };
  in mkTransactionHelper@{
       roots := [StandardInputs.currentRoot standardInputs];
       actions :=
           [mkActionHelper@{
             consumed;
             created;
             tags := TagsAndCustomInputs.tags tagsAndCustomInputs;
             appData;
             custom := TagsAndCustomInputs.customInputs tagsAndCustomInputs;
           }];
     };

-- composeAll (txs : Set Transaction) : Transaction :=
--   for (acc := emptyTx) (tx in txs) {
--     composeTransactions acc tx
--   };

fromResult
  {ErrorType}
  {DataType}
  {{Show ErrorType}}
  (result : Result ErrorType DataType)
  : DataType :=
  case result of
    | ok data := data
    | error err := failwith (Show.show err);
