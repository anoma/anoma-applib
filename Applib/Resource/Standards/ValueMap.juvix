module Applib.Resource.Standards.ValueMap;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open;
import Stdlib.Data.Set as Set open using {Set};
import Stdlib.Data.Map as Map open using {Map};
import Anoma.Builtin.System open;

type ValueMapKey :=
  mkValueMapKey@{
    unValueMapKey : Nat;
  };
-- Could be a different type (e.g., sha256 hash)

type ValueMapValue :=
  mkValueMapValue@{
    unValueMapValue : Nat;
  };

toValueMapKey {A} (argument : A) : ValueMapKey :=
  argument |> anomaEncode |> mkValueMapKey;

fromValueMapKey {A} (key : ValueMapKey) : A :=
  key |> ValueMapKey.unValueMapKey |> anomaDecode;

toValueMapValue {A} (argument : A) : ValueMapValue :=
  argument |> anomaEncode |> mkValueMapValue;

fromValueMapValue {A} (value : ValueMapValue) : A :=
  value |> ValueMapValue.unValueMapValue |> anomaDecode;

type ValueMapEntry :=
  mkValueMapEntry@{
    key : ValueMapKey;
    value : ValueMapValue;
  };

valueMapEntrytoPair {A} {B} (valueMapEntry : ValueMapEntry) : Pair A B :=
  let
    key :=
      valueMapEntry
        |> ValueMapEntry.key
        |> ValueMapKey.unValueMapKey
        |> anomaDecode;
    value :=
      valueMapEntry
        |> ValueMapEntry.value
        |> ValueMapValue.unValueMapValue
        |> anomaDecode;
  in key, value;

ValueMap : Type := Set ValueMapEntry;

lookupValueMapMaybe
  {A} {B} {{Ord A}} (key : A) (valueMap : ValueMap) : Maybe B :=
  let
    converted : Map A B :=
      Map.fromList
        (map (entry in Set.toList valueMap) {
          valueMapEntrytoPair entry
        });
  in Map.lookup key converted;

lookupValueMap {A} {B} {{Ord A}} (key : A) (valueMap : ValueMap) : B :=
  case
    lookupValueMapMaybe@{
      key;
      valueMap;
    }
  of
    | just value := value
    | nothing := failwith "ValueMapKey not found";

deriving instance
ValueMapKey-Ord : Ord ValueMapKey;

deriving instance
ValueMapKey-Eq : Eq ValueMapKey;

deriving instance
ValueMapValue-Ord : Ord ValueMapValue;

deriving instance
ValueMapValue-Eq : Eq ValueMapValue;

deriving instance
ValueMapEntry-Ord : Ord ValueMapEntry;

deriving instance
ValueMapEntry-Eq : Eq ValueMapEntry;

insertValueMap
  (key : ValueMapKey)
  (value : ValueMapValue)
  (valueMap : ValueMap)
  : ValueMap :=
  Set.insert
    mkValueMapEntry@{
      key;
      value;
    }
    valueMap;
