module Applib.Resource.Traits.Owner;

import Stdlib.Prelude open;
import Stdlib.Data.Set as Set open;

import Anoma.Resource open;
import Anoma.Identity.External open;
import Anoma.Builtin.System open;

import Applib.Authorization.Identities open;
import Applib.Resource.Standards.ValueMap open;
import Applib.Resource.Standards.Ownership open;

trait
type HasOwner ResourceT :=
  mkHasOwner@{
    get : ResourceT -> ExternalIdentity;
    set : ExternalIdentity -> ResourceT -> ResourceT
  };

instance
Resource-HasOwner : HasOwner Resource :=
  mkHasOwner@{
    --- Returns the owner ;ExternalIdentity; of the resource or the zero ;ExternalIdentity;.
    --- @param resource The ;Resource; to return the owner of.
    --- @return The owner ;ExternalIdentity;.
    get (resource : Resource) : ExternalIdentity :=
      let
        valueMap : ValueMap :=
          resource |> Resource.valueRef |> Reference.from |> Value.unValue |> anomaDecode;
      in case
           lookupValueMap@{
             key := ownershipStandardKey;
             valueMap
           }
         of
           | just value := anomaDecode value
           | nothing := Zero.externalIdentity;

    --- Sets the owner ;ExternalIdentity; of a resource.
    --- @param owner The owner to set.
    --- @param resource The resource to set the owner for.
    --- @return The updated resource.
    set (owner : ExternalIdentity) (resource : Resource) : Resource :=
      let
        oldValueMap : ValueMap :=
          resource |> Resource.valueRef |> Reference.from |> Value.unValue |> anomaDecode;
        entry :=
          mkValueMapEntry@{
            key := ownershipStandardKey;
            value := toValueMapValue owner
          };
        newValueMap := Set.insert entry oldValueMap;
      in resource@Resource{valueRef := newValueMap |> anomaEncode |> mkValue |> Reference.to}
  };
