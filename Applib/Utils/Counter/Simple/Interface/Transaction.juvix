module Applib.Utils.Counter.Simple.Interface.Transaction;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open;
import Stdlib.Data.Set as Set open using {Set};

import Anoma open;

import Applib.Helpers open;
import Applib.Identities open;
import Applib.Utils.Counter.Simple.Resource open;
import Applib.Utils.Counter.Simple.Logic open;
import Applib.Utils.Counter.Simple.Interface.Projection open;

initialize (standardInputs : StandardInputs) : Transaction :=
  let
    identity := StandardInputs.identity standardInputs;
    ephCounter :=
      mkCounter@{
        ephemeral := true;
      };
    createdCounter := mkCounter;

    consumed := Set.fromList [ephCounter];
    created := Set.fromList [createdCounter];

    nfResMapping := nullifierToResourceMapping identity consumed;
    cmResMapping := commitmentToResourceMapping created;

    nullifiers := NullifiersAndCustomInputs.nullifiers nfResMapping;
    commitments := CommitmentsAndCustomInputs.commitments cmResMapping;

    customInputs :=
      Set.union
        (NullifiersAndCustomInputs.customInputs nfResMapping)
        (CommitmentsAndCustomInputs.customInputs cmResMapping);
  in mkTransactionHelper@{
       roots := Set.singleton (StandardInputs.currentRoot standardInputs);
       actions :=
         Set.singleton
           mkActionHelper@{
             identity := Universal.identity;
             consumed := Set.singleton ephCounter;
             created := Set.singleton createdCounter;
             appData := Set.empty;
             customInputs;
             maybeNullifiers := just nullifiers;
             maybeCommitments := just commitments;
           };
     };

increment
  (standardInputs : StandardInputs) (currentCounter : Resource) : Transaction :=
  if
    | kind currentCounter /= counterKind :=
      failwith "The input resource has wrong kind."
    | else :=
      let
        identity := StandardInputs.identity standardInputs;
        updatedCounter :=
          mkCounter@{
            count := getCount currentCounter + 1;
          };

        consumed := Set.fromList [currentCounter];
        created := Set.fromList [updatedCounter];

        nfResMapping := nullifierToResourceMapping identity consumed;
        cmResMapping := commitmentToResourceMapping created;

        nullifiers := NullifiersAndCustomInputs.nullifiers nfResMapping;
        commitments := CommitmentsAndCustomInputs.commitments cmResMapping;

        customInputs :=
          Set.union
            (NullifiersAndCustomInputs.customInputs nfResMapping)
            (CommitmentsAndCustomInputs.customInputs cmResMapping);
      in mkTransactionHelper@{
           roots := Set.singleton (StandardInputs.currentRoot standardInputs);
           actions :=
             Set.singleton
               mkActionHelper@{
                 identity;
                 consumed := Set.singleton currentCounter;
                 created := Set.singleton updatedCounter;
                 appData := Set.empty;
                 customInputs;
               };
         };
