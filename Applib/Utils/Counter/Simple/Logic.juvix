module Applib.Utils.Counter.Simple.Logic;

import Stdlib.Prelude open;
import Stdlib.Data.Set as Set open using {Set};

import Anoma.Identity open;
import Anoma.Resource open;
import Anoma.Proving.Types open;

import Applib.Helpers open;
import Applib.Identities open;
import Applib.Resource.Traits open;
import Applib.Utils.Counter.Simple.Count open;
import Applib.Utils.Counter.Simple.Label open;

counterLogic (publicInputs : Logic.Instance) (privateInputs : Logic.Witness) : Bool :=
  let
    tag := Logic.Instance.tag publicInputs;
    consumed := privateInputs |> Logic.Witness.consumed |> Set.toList;
    created := privateInputs |> Logic.Witness.created |> Set.toList;
  in case consumed, created of
       | [consumedCounter], [createdCounter] :=
         sameKindCheck@{
             consumedCounter;
             createdCounter
           }
           && case both HasEphemerality.get (consumedCounter, createdCounter) of {
                | Ephemerality.Ephemeral, Ephemerality.NonEphemeral :=
                  creationCheck@{
                    createdCounter
                  }
                | Ephemerality.NonEphemeral, Ephemerality.NonEphemeral :=
                  incrementationCheck@{
                    consumedCounter;
                    createdCounter
                  }
                | _, _ := false
              }
       | _, _ := false;

sameKindCheck (consumedCounter createdCounter : Resource) : Bool :=
  kind consumedCounter == kind createdCounter;

creationCheck (createdCounter : Resource) : Bool :=
  getCount createdCounter == 0 && HasQuantity.get createdCounter == 1;

incrementationCheck (consumedCounter createdCounter : Resource) : Bool :=
  isIncremented@{
    old := consumedCounter;
    new := createdCounter
  };

isIncremented (old new : Resource) : Bool :=
  let
    expected : Nat := getCount old + 1;
    actual : Nat := getCount new;
  in expected == actual;
