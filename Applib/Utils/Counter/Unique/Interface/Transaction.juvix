module Applib.Utils.Counter.Unique.Interface.Transaction;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open;
import Stdlib.Data.Set as Set open using {Set};
import Anoma open;
import Anoma.Builtin.System open;
import Applib.Helpers open;
import Applib.Identities open;
import Applib.Resource.Errors open;
import Applib.Authorization open;
import Applib.Utils.Dummy.Resource open;
import Applib.Utils.Counter.Unique.Label open;
import Applib.Utils.Counter.Unique.Logic open;
import Applib.Utils.Counter.Unique.Resource open;
import Applib.Utils.Counter.Unique.Interface.Projection open;
import Applib.Resource.Standards.ValueMap open;
import Applib.Resource.Standards.Ownership open;

import Applib.Helpers open;

-- TODO use general initialize/traits
--- Requires a consumable resource, e.g., `Utils.Dummy.Resource`.
initialize
  (standardInputs : StandardInputs)
  (consumable : Resource)
  : Result StandardError Transaction :=
  let
    identity := StandardInputs.identity standardInputs;
    ephConsumable := consumable@Resource{ephemeral := true};
    uniqueLabel := createUniqueCounterLabel consumable;
    ephCounter :=
      mkCounter@{
        identity;
        ephemeral := true;
        uniqueLabel;
        count := 0;
      };
    newCounter :=
      mkCounter@{
        identity;
        ephemeral := false;
        uniqueLabel;
        count := 0;
      };
    consumed := Set.fromList [consumable; ephCounter];
    created := Set.fromList [ephConsumable; newCounter];

    nfResMapping := nullifierToResourceMapping identity consumed;
    cmResMapping := commitmentToResourceMapping created;

    nullifiers := NullifiersAndCustomInputs.nullifiers nfResMapping;
    commitments := CommitmentsAndCustomInputs.commitments cmResMapping;

    customInputs :=
      Set.union
        (NullifiersAndCustomInputs.customInputs nfResMapping)
        (CommitmentsAndCustomInputs.customInputs cmResMapping);
  in ok
    mkTransactionHelper@{
      roots := Set.singleton (StandardInputs.currentRoot standardInputs);
      actions :=
        Set.singleton
          mkActionHelper@{
            identity := StandardInputs.identity standardInputs;
            consumed;
            created;
            appData := Set.empty;
            customInputs;
            maybeNullifiers := just nullifiers;
            maybeCommitments := just commitments;
          };
    };

increment
  (standardInputs : StandardInputs) (currentCounter : Resource) : Transaction :=
  if
    | kind currentCounter /= counterKind (Resource.labelRef currentCounter) :=
      failwith "The input resource has wrong kind."
    | else :=
      let
        identity := StandardInputs.identity standardInputs;
        updatedCounter : Resource :=
          let
            valueMap : ValueMap :=
              currentCounter
                |> Resource.valueRef
                |> Reference.from
                |> Value.unValue
                |> anomaDecode;
            currentCount : Nat :=
              lookupValueMap@{
                key := countValueMapKey;
                valueMap;
              };
            updatedValueMap : ValueMap :=
              insertValueMap@{
                key := countValueMapKey;
                value := toValueMapValue (currentCount + 1);
                valueMap;
              };
          in currentCounter@Resource{
            ephemeral := false;
            valueRef := Reference.to
              (updatedValueMap |> anomaEncode |> mkValue);
          };
      in mkTransactionHelper@{
           roots := Set.singleton (StandardInputs.currentRoot standardInputs);
           actions :=
             Set.singleton
               mkActionHelper@{
                 identity;
                 consumed := Set.singleton currentCounter;
                 created := Set.singleton updatedCounter;
                 appData := Set.empty;
                 customInputs := Set.empty;
               };
         };
