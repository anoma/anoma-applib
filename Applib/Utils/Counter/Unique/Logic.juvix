module Applib.Utils.Counter.Unique.Logic;

import Stdlib.Prelude open;
import Stdlib.Data.Set as Set open using {Set};

import Anoma open;
import Applib.Helpers open;
import Applib.Identities open;
import Applib.Resource.Traits open;
import Applib.Utils.Counter.Unique.Interface.Projection open;
import Applib.Utils.Counter.Unique.Label open;
import Applib.Utils.Counter.Simple.Logic as Simple;

counterLogic
  (publicInputs : Logic.Instance) (privateInputs : Logic.Witness) : Bool :=
  let
    tag := Logic.Instance.tag publicInputs;
    customInputs := Logic.Witness.customInputs privateInputs;
  in case tag of
       | Consumed nullifier :=
         case lookupResource nullifier customInputs of {
           | nothing := false
           | just self :=
             case HasEphemerality.get self of {
               | Ephemeral := initializationLogic self publicInputs
               | NonEphemeral := incrementationLogic self privateInputs
             }
         }
       | Created commitment :=
         case lookupResource commitment customInputs of
           | nothing := false
           | just self :=
             case HasEphemerality.get self of
               | Ephemeral := false
               | NonEphemeral := true;

initializationLogic (self : Resource) (publicInputs : Logic.Instance) : Bool :=
  Simple.quantityCheck@{
    self;
  }
    && isNullifierPresent@{
         nullifier := getNullifierfFromLabel self;
         nullifierSet := Logic.Instance.nullifiers publicInputs;
       };

incrementationLogic (self : Resource) (privateInputs : Logic.Witness) : Bool :=
  Simple.incrementationLogic@{
    self;
    privateInputs;
  };
