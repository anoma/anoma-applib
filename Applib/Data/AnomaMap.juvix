module Applib.Data.AnomaMap;

import Stdlib.Prelude open;
import Stdlib.Data.Map as Map open using {Map};
import Anoma.Builtin.System open using {builtinAnomaEncode; builtinAnomaDecode};
import Anoma.Encode open;

type AnomaMap := internalMk (Map Nat Nat)with
empty : AnomaMap := internalMk Map.empty;

size : AnomaMap -> Nat
  | (internalMk m) := Map.size m;

lookup {Key Value : Type} : Key -> AnomaMap -> Maybe (Encoded Value)
  | key (internalMk a) :=
    Map.lookup (builtinAnomaEncode key) a |> map Encoded.coerceFromNat;

lookupDecode {Key Value : Type} (k : Key) (m : AnomaMap) : Maybe Value :=
  map decode (lookup k m);

insert {Key Value : Type} : Key -> Value -> AnomaMap -> AnomaMap
  | k v (internalMk a) :=
    internalMk
      (Map.insert (builtinAnomaEncode k) (builtinAnomaEncode v) a);
end;
