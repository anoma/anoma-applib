-- based on anoma checkout b27ee767dce1b95a047475395cc75618a2516fa0
module BaseLayer.ResourceMachine;

import Anoma.Encode open;
import Stdlib.Debug.Fail open;
import Anoma.Builtin.System open;
import Anoma.Builtin.ByteArray open;
import Stdlib.Prelude open;
import Anoma.State.CommitmentTree open;
import Stdlib.Data.Map as Map open;
import Anoma.Primitives.FixedSize open;

-- The reference to the ;Resource;.
type Tag :=
  | Created Commitment
  | Consumed Nullifier
with
  toNat : Tag -> Nat
    | (Created x) := Commitment.toNat x
    | (Consumed x) := Nullifier.toNat x;

  fromNat (n : Nat) : Tag :=
    if
      | isNullifier n := Consumed (Nullifier.fromNat n)
      | isCommitment n := Created (Commitment.fromNat n)
      | else :=
        failwith "The given natural is neither a nullifier nor a commitment";
end;

open Tag using {Consumed; Created} public;

type Nullifier := privateMk Nat
with
  toNat : Nullifier -> Nat
    | (privateMk c) := c;

  fromNat : Nat -> Nullifier := privateMk;

  deriving instance
  Nullifier-Ord : Ord Nullifier;

  deriving instance
  Nullifier-Eq : Eq Nullifier;
end;

--- The nullifier key type describing a secret required to compute the ;Nullifier; of a resource
type NullifierKey :=
  mk@{
    unNullifierKey : ByteArray;
  }
with
  --- Implements the ;FixedSize; trait for ;NullifierKey;.
  instance
  NullifierKey-FixedSize : FixedSize NullifierKey := FixedSize.mk 64;

  deriving instance
  NullifierKey-Ord : Ord NullifierKey;

  deriving instance
  NullifierKey-Eq : Eq NullifierKey;
end;

type Commitment := privateMk Nat
with
  toNat : Commitment -> Nat
    | (privateMk c) := c;

  fromNat : Nat -> Commitment := privateMk;

  deriving instance
  Commitment-Eq : Eq Commitment;

  deriving instance
  Commitment-Ord : Ord Commitment;
end;

deriving instance
Tag-Eq : Eq Tag;

deriving instance
Tag-Ord : Ord Tag;

-- always 0
-- in compliance_unit.ex it is checked that the proof is 0, otherwise it errors
type Proof := privateMk Nat
with
  mk : Proof := privateMk 0;
end;

-- always 0
-- in compliance_unit.ex it is checked that the verifying key is 0, otherwise it errors
type VerifyingKey := privateMk Nat
with
  mk : VerifyingKey := privateMk 0;
end;

type ConsumedItem :=
  mk@{
    nullifier : Nullifier;
    root : Root;
    logic : Nat;
  };

type DeltaHash := privateMk Nat;

type CreatedItem :=
  mk@{
    commitment : Commitment;
    logic : Nat;
  };

type Instance :=
  mk@{
    consumed : List ConsumedItem;
    created : List CreatedItem;
    deltaHash : DeltaHash;
  };

type ComplianceUnit :=
  privateMk@{
    proof : Proof;
    instance : Instance;
    verifyingKey : VerifyingKey;
  }
with
  mk (instance : Instance) : ComplianceUnit :=
    privateMk@{
      instance;
      proof := Proof.mk;
      verifyingKey := VerifyingKey.mk;
    };
end;

type Logic : Type :=
  mk@{
    compute : Logic.Arg -> Bool;
  }
with
  -- BUG: the positive shouldn't be needed
  positive
  type Arg :=
    mk@{
      self : Resource;
      isConsumed : Bool;
      consumed : List Resource;
      created : List Resource;
      appData : AppData;
    };
end;

type Label := mk Nat
with
  toNat : Label -> Nat
    | (mk l) := l;

  fromNat : Nat -> Label := mk;

  deriving instance
  Label-Ord : Ord Label;

  deriving instance
  Label-Eq : Eq Label;
end;

--- A fixed-size data type encoding a number to be used once ensuring that the resource commitment is unique.
--- NOTE: This should be a number having an at most negligible chance of repeating is sufficient, e.g., a pseudo-random number.
type Nonce := internalMk ByteArray
with
  size : Nat := 32;

  fromNat : Nat -> Nonce := fromAnomaContents size >> internalMk;

  from32SizedByteArray : ByteArray -> Nonce := internalMk;

  toNat : Nonce -> Nat
    | (internalMk nonce) := toAnomaContents nonce;

  instance
  Nonce-FixedSize : FixedSize Nonce := FixedSize.mk size;

  deriving instance
  Nonce-Ord : Ord Nonce;

  deriving instance
  Nonce-Eq : Eq Nonce;
end;

--- The nullifier key type describing a secret required to compute the ;Nullifier; of a resource
type NullifierKeyCommitment := mk ByteArray
with
  fromByteArray : ByteArray -> NullifierKeyCommitment := mk;

  toByteArray : NullifierKeyCommitment -> ByteArray
    | (mk b) := b;

  instance
  NullifierKeyCommitment-FixedSize : FixedSize NullifierKeyCommitment :=
    FixedSize.mk 32;

  deriving instance
  NullifierKeyCommitment-Ord : Ord NullifierKeyCommitment;

  deriving instance
  NullifierKeyCommitment-Eq : Eq NullifierKeyCommitment;
end;

builtin anoma-resource
type Resource :=
  mk@{
    label : Label;
    logic : Encoded Logic;
    value : AnomaAtom;
    quantity : Nat;
    ephemeral : Bool;
    nonce : Nonce;
    nullifierKeyCommitment : NullifierKeyCommitment;
    unusedRandSeed : Nat;
  };

-- Corresponds to Set in Hoon (MapSet in Elixir)
module AnomaSet;
  builtin anoma-set
  axiom AnomaSet (A : Type) : Type;

  builtin anoma-set-to-list
  axiom toList {A} (set : AnomaSet A) : List A;

  builtin anoma-set-from-list
  axiom fromList {A} (list : List A) : AnomaSet A;

  empty {A} : AnomaSet A := fromList [];
end;

open AnomaSet using {AnomaSet} public;

type AnomaMap (key value : Type) := privateMk (AnomaSet (Pair key value))
with
  fromList {key} {value} : List (Pair key value) -> AnomaMap key value :=
    AnomaSet.fromList >> privateMk;

  toList {key} {value} : AnomaMap key value -> List (Pair key value)
    | (privateMk m) := AnomaSet.toList m;

  toMap {key} {value} {{Ord key}} : AnomaMap key value -> Map key value
    | (privateMk m) := Map.fromList (AnomaSet.toList m);

  fromMap {key} {value} : Map key value -> AnomaMap key value :=
    Map.toList >> fromList;
end;

type AnomaAtom := mk Nat
with
  fromNat : Nat -> AnomaAtom := mk;

  toNat : AnomaAtom -> Nat
    | (mk n) := n;

  deriving instance
  AnomaAtomEqI : Eq AnomaAtom;

  deriving instance
  AnomaAtomOrdI : Ord AnomaAtom;
end;

-- BUG: positive should not be necessary
positive
type RawTag := privateMk Nat
with
  fromTag : Tag -> RawTag := Tag.toNat >> fromNat;

  toTag : RawTag -> Tag := toNat >> Tag.fromNat;

  toNat : RawTag -> Nat
    | (privateMk c) := c;

  fromNat : Nat -> RawTag := privateMk;

  deriving instance
  RawTag-Eq : Eq RawTag;

  deriving instance
  RawTag-Ord : Ord RawTag;
end;

type AppData := privateMk (AnomaMap RawTag AppData.Value)
with
  -- we shouldn't need the positive assertion here. It is compiler a bug
  positive
  type Value :=
    mk@{
      atom : AnomaAtom;
      deletionCriteria : Bool;
    }
  with
    fromAnomaAtom (atom : AnomaAtom) : Value :=
      mk@{
        atom;
        deletionCriteria := true;
      };
  end;

  toMap : AppData -> Map RawTag AnomaAtom
    | (privateMk m) :=
      AnomaMap.toList m |> map \{(k, v) := k, Value.atom v} |> Map.fromList;

  fromMap : Map RawTag AnomaAtom -> AppData :=
    Map.toList
      >> map \{(k, v) := k, Value.fromAnomaAtom v}
      >> AnomaMap.fromList
      >> privateMk;
end;

builtin anoma-delta
axiom Delta : Type;

module Kind;
  builtin anoma-kind
  axiom Kind : Type;

  instance
  KindEq : Eq Kind :=
    Eq.mk@{
      isEqual (a b : Kind) : Bool :=
        builtinAnomaEncode a == builtinAnomaEncode b;
    };
end;

open Kind using {Kind} public;

instance
ShowKindI : Show Kind :=
  Show.mk@{
    show (_ : Kind) : String := "<kind>";
  };

-- Unused
-- builtin anoma-resource-delta
-- axiom resourceDelta : Resource -> Delta;

builtin anoma-resource-commitment
axiom rawCommitment : Resource -> Nat;

commitment : Resource -> Commitment := rawCommitment >> Commitment.fromNat;

-- FIXME The computation of the nullifier should depend on the nullifier key
builtin anoma-resource-nullifier
axiom rawNullifier : Resource -> Nat;

nullifier : Resource -> Nullifier := rawNullifier >> Nullifier.fromNat;

builtin anoma-resource-kind
axiom kind : Resource -> Kind;

-- type LogicProof : Type :=
--   mk@{
--     resource : Resource;
--     inputs : Pair Instance Witness;
--   };

-- ComplianceProof : Type := Nat;

-- type Proof :=
--   | compliance
--   | logic Resource (Pair Instance Witness);

-- mkProofCompliance (_ : ComplianceProof) : Proof := Proof.compliance;

-- mkProofLogic
--   (resource : Resource)
--   (publicInputs : Instance)
--   (privateInputs : Witness)
--   : Proof := Proof.logic resource (publicInputs, privateInputs);

builtin anoma-action
type Action :=
  mk@{
    commitments : List Commitment;
    nullifiers : List Nullifier;
    resourceLogicProofs : AnomaMap RawTag (todo {Type});
    complianceUnits : AnomaSet ComplianceUnit;
    appData : AppData;
  }
with
  builtin anoma-action-delta
  axiom delta : Action -> Delta;

-- We need it to compute the Delta in unbalanced transactions
-- builtin anoma-actions-delta
-- axiom listDelta : List Action -> Delta;
end;

-- builtin anoma-prove-delta
-- axiom proveDelta : Delta -> Nat;

-- builtin anoma-zero-delta
-- axiom zeroDelta : Delta;

-- builtin anoma-add-delta
-- axiom addDelta : Delta -> Delta -> Delta;

-- builtin anoma-sub-delta
-- axiom subDelta : Delta -> Delta -> Delta;

type CommitmentRoot := privateMk Nat
with
  fromNat : Nat -> CommitmentRoot := privateMk;

  toNat : CommitmentRoot -> Nat
    | (privateMk r) := r;
end;

type DeltaProof := privateMk Nat
with
  -- TODO replace with builtin when ready
  mk : DeltaProof := privateMk 0;
end;

type Transaction :=
  privateMk@{
    roots : AnomaSet CommitmentRoot;
    actions : AnomaSet Action;
    deltaProof : DeltaProof;
  }
with
  mk
    (roots : AnomaSet CommitmentRoot)
    (actions : AnomaSet Action)
    : Transaction :=
    privateMk@{
      roots;
      actions;
      deltaProof := DeltaProof.mk;
    };
end;
