module Anoma.Builtin.ByteArray;

import Stdlib.Prelude open;
import Stdlib.Debug.Trace open;
import Stdlib.Debug.Fail open;
import BaseLayer.AnomaAtom open;
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};
import Anoma.Data.Json open;
import Mtl open;
import Anoma.Primitives.FixedSize open;

module ByteArray;
  builtin bytearray
  axiom ByteArray : Type;

  builtin bytearray-from-list-byte
  axiom mk : List Byte -> ByteArray;

  toList (b : ByteArray) : List Byte :=
    let
      go (acc : List Byte) (payload : Nat) : (len : Nat) -> List Byte
        | zero := reverse acc
        -- Note `fromNat` takes the modulo
        | (suc ibyte) := go (fromNat payload :: acc) (div payload 256) ibyte;
    in go [] (rawToAnomaContents b) (size b);

  zero (length : Nat) : ByteArray := mk (replicate length 0x0);

  --- The number of bytes in the ;ByteArray;
  builtin bytearray-length
  axiom size : ByteArray -> Nat;

  builtin anoma-bytearray-to-anoma-contents
  axiom rawToAnomaContents : ByteArray -> Nat;

  toAnomaContents : ByteArray -> AnomaAtom :=
    rawToAnomaContents >> AnomaAtom.fromNat;

  builtin anoma-bytearray-from-anoma-contents
  axiom rawFromAnomaContents (size : Nat) (contents : Nat) : ByteArray;

  fromAnomaContents (size : Nat) (contents : AnomaAtom) : ByteArray :=
    rawFromAnomaContents@{
      size;
      contents := AnomaAtom.toNat contents;
    };

  instance
  ByteArray-Show : Show ByteArray :=
    Show.mk@{
      show : ByteArray -> String := toList >> Show.show;
    };

  instance
  ByteArray-ToJson : ToJson ByteArray :=
    ToJson.mk@{
      toJson (b : ByteArray) : Json := Json.number (rawToAnomaContents b);
    };
end;

open ByteArray using {ByteArray; fromAnomaContents; toAnomaContents} public;

instance
ByteArray-Ord : Ord ByteArray :=
  let
    prod (b : ByteArray) : _ := ByteArray.size b, toAnomaContents b;
  in Ord.mk@{
       compare (lhs rhs : ByteArray) : Ordering :=
         Ord.compare (prod lhs) (prod rhs);
     };

instance
ByteArray-Eq : Eq ByteArray := fromOrdToEq;

execState
  {S A : Type}
  {M : Type â†’ Type}
  {{Functor M}}
  (s : S)
  (m : StateT S M A)
  : M S := Functor.map snd (runState s m);

type BytesBuilder (A : Type) :=
  mk@{
    unwrap : StateT BytesBuilder.State Identity A;
  }
with
  State : Type := List Byte;

  run {A} : BytesBuilder A -> ByteArray
    | (mk st) := ByteArray.mk (reverse (Identity.run (execState [] st)));

  byte (b : Byte) : BytesBuilder Unit := mk (modify \{acc := b :: acc});

  instance
  BytesBuilder-Functor : Functor BytesBuilder :=
    Functor.mk@{
      map {A} {B} (f : A -> B) : BytesBuilder A -> BytesBuilder B
        | (mk p) := mk (Functor.map f p);
    };

  instance
  BytesBuilder-Applicative : Applicative BytesBuilder :=
    Applicative.mk@{
      pure {A} (a : A) : BytesBuilder A := mk (Applicative.pure a);
      ap {A} {B} : BytesBuilder (A -> B) -> BytesBuilder A -> BytesBuilder B
        | (mk f) (mk p) := mk (Applicative.ap f p);
    };

  instance
  BytesBuilder-Monad : Monad BytesBuilder :=
    Monad.mk@{
      bind {A} {B} : BytesBuilder A -> (A -> BytesBuilder B) -> BytesBuilder B
        | (mk x) m :=
          mk
            do {
              a <- x;
              BytesBuilder.unwrap (m a);
            };
    };
end;

type BytesConsumer A :=
  mk@{
    unwrap : StateT (List Byte) (ErrorT BytesConsumer.ConsumerError Identity) A;
  }
with
  type ConsumerError := mk String
  with
    instance
    ConsumerError-Show : Show ConsumerError :=
      Show.mk \{(ConsumerError.mk err) := err};
  end;

  run {A} : BytesConsumer A -> ByteArray -> Result ConsumerError A
    | (mk p) str :=
      Identity.run (runError (evalState (ByteArray.toList str) p));

  instance
  BytesConsumer-Functor : Functor BytesConsumer :=
    Functor.mk@{
      map {A} {B} (f : A -> B) : BytesConsumer A -> BytesConsumer B
        | (mk p) := mk (Functor.map f p);
    };

  instance
  BytesConsumer-Applicative : Applicative BytesConsumer :=
    Applicative.mk@{
      pure {A} (a : A) : BytesConsumer A := mk (Applicative.pure a);
      ap {A} {B} : BytesConsumer (A -> B) -> BytesConsumer A -> BytesConsumer B
        | (mk f) (mk p) := mk (Applicative.ap f p);
    };

  instance
  BytesConsumer-Monad : Monad BytesConsumer :=
    Monad.mk@{
      bind
        {A} {B} : BytesConsumer A -> (A -> BytesConsumer B) -> BytesConsumer B
        | (mk x) m :=
          mk
            do {
              a <- x;
              BytesConsumer.unwrap (m a);
            };
    };

  byte : BytesConsumer Byte :=
    mk
      do {
        l <- get;
        case l of {
          | [] := throw (ConsumerError.mk "end of input")
          | x :: xs :=
            do {
              put xs;
              pure x;
            }
        };
      };

end;

trait
type FromBytes (T : Type) :=
  mk@{
    fromBytes : BytesConsumer T;
  }
with
  -- Big endian
  WordN {A} {{FromNatural A}} (numBytes : Nat) : FromBytes A :=
    let
      go (acc : Nat) : (numByte : Nat) -> BytesConsumer A
        | zero := pure (fromNat acc)
        | (suc ibyte) :=
          do {
            bi <- Byte.toNat <$> BytesConsumer.byte;
            go (acc + bi * pow 256 ibyte) ibyte;
          };
    in FromBytes.mk (go 0 numBytes);
end;

open FromBytes using {fromBytes} public;

trait
type ToBytes (T : Type) :=
  mk@{
    toBytes : T -> BytesBuilder Unit;
  }
with
  -- Big endian
  WordN {A} (toNat : A -> Nat) (numBytes : Nat) : ToBytes A :=
    let
      go (n : Nat) : (numByte : Nat) -> BytesBuilder Unit
        | zero := pure unit
        | (suc ibyte) :=
          do {
            BytesBuilder.byte (FromNatural.fromNat (div n (pow 256 ibyte)));
            go n ibyte;
          };
    in ToBytes.mk \{n := go (toNat n) numBytes};
end;

open ToBytes using {toBytes} public;

toByteArray {A} {{ToBytes A}} (a : A) : ByteArray :=
  BytesBuilder.run (toBytes a);

fromByteArray
  {A} {{FromBytes A}} (a : ByteArray) : Result BytesConsumer.ConsumerError A :=
  BytesConsumer.run fromBytes a;

instance
Byte-FromBytes : FromBytes Byte :=
  FromBytes.mk@{
    fromBytes := BytesConsumer.byte;
  };

instance
Byte-ToBytes : ToBytes Byte :=
  ToBytes.mk@{
    toBytes (b : Byte) : BytesBuilder Unit := BytesBuilder.byte b;
  };

instance
ByteArray-FromBytes : FromBytes ByteArray :=
  FromBytes.mk@{
    fromBytes :=
      do {
        numBytes <- BytesConsumer.byte;
        pure (ByteArray.mk []);
      };
  };

pow {A} {{FromNatural A}} {{Natural A}} : A -> Nat -> A
  | a zero := 1
  | a (suc b) := a * pow a b;

--- 8 byte word
type Word32 := privateMk Nat
with
  fromNat (n : Nat) : Word32 := privateMk n;

  toNat : Word32 -> Nat
    | (privateMk n) := mod n (pow 2 32);

  instance
  FromNat-Word32 : FromNatural Word32 := FromNatural.mkFromNatural fromNat;

  instance
  FixedSize-Word32 : FixedSize Word32 := FixedSize.mk 8;

  instance
  Show-Word32 : Show Word32 :=
    Show.mk@{
      show : Word32 -> String
        | (privateMk n) := Show.show n;
    };

  instance
  FromBytes-Word32 : FromBytes Word32 := FromBytes.WordN 4;

  instance
  ToBytes-Word32 : ToBytes Word32 := ToBytes.WordN toNat 4;
end;

instance
ToBytes-Bool : ToBytes Bool :=
  ToBytes.mk
    \{
      | false := BytesBuilder.byte 0
      | true := BytesBuilder.byte 1
    };

instance
FromBytes-Bool : FromBytes Bool :=
  FromBytes.mk
    do {
      b <- Byte.toNat <$> BytesConsumer.byte;
      pure (b /= 0);
    };

instance
ToBytes-List {A} {{ToBytes A}} : ToBytes (List A) :=
  ToBytes.mk
    \{l :=
      do {
        let
          len : Word32 := fromNat (length l);
        in
        toBytes len;
        mapA_ toBytes l;
      }};

instance
FromBytes-List {A} {{FromBytes A}} : FromBytes (List A) :=
  FromBytes.mk
    do {
      len <- fromBytes {Word32};
      replicateA (Word32.toNat len) fromBytes;
    };

--- 8 byte integer
type Int32 := privateMk Int
with
  fromInt (n : Int) : Int32 := privateMk n;

  toInt : Int32 -> Int
    | (privateMk n) :=
      case n of
        | Int.ofNat pos := Int.ofNat (mod pos (pow 2 31))
        | Int.negSuc neg := Int.negSuc (mod neg (pow 2 31));

  instance
  FromNat-Int32 : FromNatural Int32 := FromNatural.mkFromNatural fromNat;

  instance
  FixedSize-Int32 : FixedSize Int32 := FixedSize.mk 4;

  instance
  Show-Int32 : Show Int32 :=
    Show.mk@{
      show : Int32 -> String
        | (privateMk n) := Show.show n;
    };

  instance
  FromBytes-Int32 : FromBytes Int32 :=
    FromBytes.mk
      do {
        w <- Word32.toNat <$> fromBytes;
        if
          | w < pow 2 31 := pure (privateMk (Int.fromNat w))
          | else := pure (privateMk -1);
      };

  -- TODO padding
  instance
  ToBytes-Int32 : ToBytes Int32 :=
    ToBytes.mk
      \{i :=
        case toInt i of
          | Int.ofNat n := toBytes {Word32} (fromNat n)
          | Int.negSuc n :=
            toBytes {Word32} (fromNat (sub (pow 2 32) (n + 1)))};

end;

-- test {A} {{ToBytes A}} {{FromBytes A}} {{Show A}} (a : A) : String :=
--   show (fromByteArray {A} (toByteArray a));

main : _ :=
  let
    -- n : List Word32 := [234; 12; 10; 77];
    n : Int32 := Int32.fromInt (pow 2 31 - 1);
  -- n : Word32 := Word32.fromNat 7;
  in trace n
    >-> trace (show (toByteArray n))
    >-> show (fromByteArray {Int32} (toByteArray n));
